/*==============================================================================
==============================================================================*/

//******************************************************************************
//******************************************************************************
//******************************************************************************

#include "stdafx.h"

#include <pthread.h> 

#include "ccSynchLock.h"

namespace CC
{

//******************************************************************************
//******************************************************************************
//******************************************************************************

void chkerror(int aRet, char* aLabel)
{
   if (aRet == 0)return;
   printf("FAIL %s %d\n", aLabel, aRet);
   exit(1);
}

//******************************************************************************
//******************************************************************************
//******************************************************************************

class SynchLock::Specific
{
public:
   pthread_rwlock_t mRWLock;
   pthread_mutex_t mMutex;
};

//******************************************************************************
//******************************************************************************
//******************************************************************************

SynchLock::SynchLock() 
{
   mSpecific = new Specific;
   int ret;

   ret = pthread_mutex_init(&mSpecific->mMutex, NULL);
   chkerror(ret, "pthread_mutex_init");
   return;

   ret = pthread_rwlock_init(&mSpecific->mRWLock, 0);
   chkerror(ret, "pthread_rwlock_init");
   return;
}

//******************************************************************************
//******************************************************************************
//******************************************************************************

SynchLock::~SynchLock() 
{
   int ret;

   ret = pthread_mutex_destroy(&mSpecific->mMutex);
   chkerror(ret, "pthread_mutex_destroy");
   delete mSpecific;
   return;

   ret = pthread_rwlock_destroy(&mSpecific->mRWLock);
   chkerror(ret, "pthread_rwlock_destroy");
   delete mSpecific;
   return;

}

//******************************************************************************
//******************************************************************************
//******************************************************************************

void SynchLock::lock()
{
   int ret;

   ret = pthread_mutex_lock(&mSpecific->mMutex);
   chkerror(ret, "pthread_mutex_lock");
   return;

   ret = pthread_rwlock_wrlock(&mSpecific->mRWLock);
   chkerror(ret, "pthread_rwlock_wrlock");
   return;
}

//******************************************************************************
//******************************************************************************
//******************************************************************************

void SynchLock::unlock()
{
   int ret;

   ret = pthread_mutex_unlock(&mSpecific->mMutex);
   chkerror(ret, "pthread_mutex_unlock");
   return;

   ret = pthread_rwlock_unlock(&mSpecific->mRWLock);
   chkerror(ret, "pthread_rwlock_unlock");
   return;
}

//******************************************************************************
//******************************************************************************
//******************************************************************************
}//namespace

